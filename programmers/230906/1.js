// 표현 가능한 이진트리

// 당신은 이진트리를 수로 표현하는 것을 좋아합니다.
// 이진트리를 수로 표현하는 방법은 다음과 같습니다.
// 이진수를 저장할 빈 문자열을 생성합니다.
// 주어진 이진트리에 더미 노드를 추가하여 포화 이진트리로 만듭니다. 루트 노드는 그대로 유지합니다.
// 만들어진 포화 이진트리의 노드들을 가장 왼쪽 노드부터 가장 오른쪽 노드까지, 왼쪽에 있는 순서대로 살펴봅니다. 노드의 높이는 살펴보는 순서에 영향을 끼치지 않습니다.
// 살펴본 노드가 더미 노드라면, 문자열 뒤에 0을 추가합니다. 살펴본 노드가 더미 노드가 아니라면, 문자열 뒤에 1을 추가합니다.
// 문자열에 저장된 이진수를 십진수로 변환합니다.
// 이진트리에서 리프 노드가 아닌 노드는 자신의 왼쪽 자식이 루트인 서브트리의 노드들보다 오른쪽에 있으며, 자신의 오른쪽 자식이 루트인 서브트리의 노드들보다 왼쪽에 있다고 가정합니다.
// 다음은 이진트리를 수로 표현하는 예시입니다.
// 주어진 이진트리는 다음과 같습니다.
// 주어진 이진트리에 더미노드를 추가하여 포화 이진트리로 만들면 다음과 같습니다. 더미 노드는 점선으로 표시하였고, 노드 안의 수는 살펴보는 순서를 의미합니다.
// 노드들을 왼쪽에 있는 순서대로 살펴보며 0과 1을 생성한 문자열에 추가하면 "0111010"이 됩니다. 이 이진수를 십진수로 변환하면 58입니다.
// 당신은 수가 주어졌을때, 하나의 이진트리로 해당 수를 표현할 수 있는지 알고 싶습니다.
// 이진트리로 만들고 싶은 수를 담은 1차원 정수 배열 numbers가 주어집니다. numbers에 주어진 순서대로 하나의 이진트리로 해당 수를 표현할 수 있다면 1을, 표현할 수 없다면 0을 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해주세요.

function solution(numbers) {
  var answer = [];

  numbers = numbers.map( (el) => el.toString(2).split("").reverse());

  const isPossible = (number) => {
    while (true) {
      if (number.length === 1 && number[0] === "1") {
        return true;
      }

      let newNumber = [];

      for (let i = 0; i < number.length; i += 4) {
        if (number[i + 1] === "0" || !number[i + 1]) {
          if (number[i] === "1" || number[i + 2] === "1") {
            return false;
          }
        }

        newNumber.push(number[i + 1] || "0");

        if (number[i + 3]) {
          newNumber.push(number[i + 3]);
        }
      }

      number = newNumber;
    }
  };

  answer = numbers.map( (el) => (isPossible(el) ? 1 : 0));

  return answer;
}

console.log(solution([7, 42, 5])) // [1, 1, 0]
console.log(solution([63, 111, 95])) // [1, 1, 0]