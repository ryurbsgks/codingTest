// 블록 게임

// 프렌즈 블록이라는 신규 게임이 출시되었고, 어마어마한 상금이 걸린 이벤트 대회가 개최 되었다.
// 이 대회는 사람을 대신해서 플레이할 프로그램으로 참가해도 된다는 규정이 있어서, 게임 실력이 형편없는 프로도는 프로그램을 만들어서 참가하기로 결심하고 개발을 시작하였다.
// 프로도가 우승할 수 있도록 도와서 빠르고 정확한 프로그램을 작성해 보자.
// 게임규칙
// 아래 그림과 같이 1×1 크기의 블록을 이어 붙여 만든 3 종류의 블록을 회전해서 총 12가지 모양의 블록을 만들 수 있다.
// 1 x 1 크기의 정사각형으로 이루어진 N x N 크기의 보드 위에 이 블록들이 배치된 채로 게임이 시작된다. (보드 위에 놓인 블록은 회전할 수 없다). 모든 블록은 블록을 구성하는 사각형들이 정확히 보드 위의 사각형에 맞도록 놓여있으며, 선 위에 걸치거나 보드를 벗어나게 놓여있는 경우는 없다.
// 플레이어는 위쪽에서 1 x 1 크기의 검은 블록을 떨어뜨려 쌓을 수 있다. 검은 블록은 항상 맵의 한 칸에 꽉 차게 떨어뜨려야 하며, 줄에 걸치면 안된다.
// 이때, 검은 블록과 기존에 놓인 블록을 합해 속이 꽉 채워진 직사각형을 만들 수 있다면 그 블록을 없앨 수 있다.
// 예를 들어 검은 블록을 떨어뜨려 아래와 같이 만들 경우 주황색 블록을 없앨 수 있다.
// 빨간 블록을 가로막던 주황색 블록이 없어졌으므로 다음과 같이 빨간 블록도 없앨 수 있다.
// 그러나 다른 블록들은 검은 블록을 떨어뜨려 직사각형으로 만들 수 없기 때문에 없앨 수 없다.
// 따라서 위 예시에서 없앨 수 있는 블록은 최대 2개이다.
// 보드 위에 놓인 블록의 상태가 담긴 2차원 배열 board가 주어질 때, 검은 블록을 떨어뜨려 없앨 수 있는 블록 개수의 최댓값을 구하라.

function solution(board) {
  var answer = 0;

  let arr = new Array(201).fill().map( (el) => new Array(6).fill(-1));
  let newArr = [];
  let length = board.length;

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      if (board[i][j] > 0) {

        let b = board[i][j];

        arr[b][0] = b;
        arr[b][1] = arr[b][1] === -1 ? i : Math.min(arr[b][1], i);
        arr[b][3] = arr[b][3] === -1 ? i : Math.max(arr[b][3], i);
        arr[b][2] = arr[b][2] === -1 ? j : Math.min(arr[b][2], j);
        arr[b][4] = arr[b][4] === -1 ? j : Math.max(arr[b][4], j);

      }
    }
  }

  for (let i = 0; i < length; i++) {
    for (let j = 0; j < length; j++) {
      if (board[i][j] > 0) {

        let b = board[i][j];

        if (arr[b][5] === -1) {
          arr[b][5] = 1;
          newArr.push(arr[b]);
        }

      }
    }
  }

  for (let i = 0; i < newArr.length; i++) {

    let b = newArr[i];

    if (b[0] === 0) {
      continue;
    }

    let count = 0;

    for (let j = b[1]; j <= b[3]; j++) {
      for (let k = b[2]; k <= b[4]; k++) {
        if (j < b[3] && board[j][k] === 0) {

          let isEmpty = true;

          for (let l = 0; l <= j; l++) {
            if (board[l][k] !== 0) {
              isEmpty = false;

              break;
            }
          }

          if (isEmpty === true) {
            count++;
          }

        }
      }
    }

    if (count === 2) {
      answer++;

      for (let j = b[1]; j <= b[3]; j++) {
        for (let k = b[2]; k <= b[4]; k++) {
          board[j][k] = 0;
        }
      }

      newArr[i][0] = 0;

      if (i > 0) {
        i -= 2;
      }
    }

  }

  return answer;
}

console.log(solution([[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,4,0,0,0],[0,0,0,0,0,4,4,0,0,0],[0,0,0,0,3,0,4,0,0,0],[0,0,0,2,3,0,0,0,5,5],[1,2,2,2,3,3,0,0,0,5],[1,1,1,0,0,0,0,0,0,5]])) // 2